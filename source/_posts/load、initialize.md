
---
title: load、initialize
layout: post
date:  2018-05-03 21:39:55
author: "refraincc"
tags:
	- Coder
---





### + (void) load;

##### 对于加入运行期系统的每个类（class）以及（catagory），必定会调用此方法，而且只调用一次，通常是指在程序启动的时候。如果类和分类都定义了load方法，则优先调用类里的，然后再依次调用分类里的。在执行子类的load方法之前，必定先执行所有超类的load方法，而如果代码还依赖了其他程序库，那么程序库里相对应的load方法也必定会先执行。
##### 有个重要的事情需要注意，那就是load方法并不像普通的方法那样，它并不遵从那套继承规则。如果某个类本身没有实现load方法，那么不管其各级超类是否有实现此方法，系统都不会调用。此外，分类和其所属的类里，都可能出现load方法。此时两种实现代码都会调用，类的实现要比分类的实现先执行。
##### 在加载阶段，如果类实现了load方法，那么系统就会调用它。分类里也可以定义此方法，类的load方法要比分类中的先调用。与其他方法不同，load方法不参与覆写机制。

### + （void）initialize;

##### 对于每个类来说，该方法都会在程序首次用该类之前调用，且只调用一次。它是由运行期系统来调用的，绝不应该通过代码直接调用。虽与load相似，但却有几个非常重要的区别。首先，它是‘惰性调用的’，也就是说，只有当程序用到了相关的类时，才会调用。因此如果某个类一直没有使用，那么其initialize方法就一直不会运行。这也就等于说，应用程序无需先把每个类的initialize都执行一遍，这与load方法不同，对于load来说，应用程序必须阻塞并等所有类的load方法都执行完，才能继续。

##### 此方法与load还有一个区别，就是运行期系统在执行该方法时，是处于正常装台的，因此，从运行期系统完整度来讲，此时可以安全使用并调用任意类的任意方法。并且，运行期系统也能确保initialize方法一定会在‘线程安全的环境’种执行，这就是说，只有执行initialize的那个线程可以操作类或类实例，其他线程都要先阻塞，等着initialize执行完。

##### 最后一个区别是：initialize方法与其他消息一样，如果某个类未实现它，而其超类实现了，那么就会运行超类的实现代码。也就是说，initialize也遵循通常的继承规则。

##### 首次使用某个类之前，系统会向其发送initialize消息，由于此方法遵从普通的覆写规则，所以通常应该里面判断当前要初始化的哪个类。

